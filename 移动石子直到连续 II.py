class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        min_idx, max_idx = stones[0], stones[-1]
        n = len(stones)
        # max的思路还好，min的思路。。。太难了，记录一下
        # 最大操作数：第一次我们只能选择 stones[0]或者 stones[n−1] 进行移动。因为移动后不能继
        # 续成为端点石子，所以若移动 stones[0]，则 stones[1] 到 stones[0] 之间的空位将会被丢
        # 弃，若移动 stones[n−1]，则 stones[n−1] 到 stones[n−2] 之间的空位将会被丢弃，如果我
        # 们每次移动都将端点石子移到其最近的空位，则第一次移动后，若移动 stones[0]，则此时最左端的
        # 两个石子一定保证相邻，此时我们在之后的操作中都将最左端的石子移动到与之最近的空位中，直至不
        # 能进行操作，这样剩下的空位都不会被丢弃。若移动 stones[n−1]，同理此时最右端的两个石子一定
        # 保证相邻，此时我们在之后的操作中都将最右端的石子移动到与之最近的空位中，直至不能进行操作，
        # 这样剩下的空位同样都不会被丢弃。由于每次操作必定会少一个空位，所以在第一次移动后，上述的两
        # 者操作都是最优操作，又因为最初的总空位是固定的，判断一下第一次是移动stones[0]还是stones
        # [n-1] 即可

        # 最小操作数（这谁能想到）：最终全部石子连续等价于全部的石子最终都移动到了一个长度为 n 的窗
        # 口中。
        # 若窗口中有连续的 n−1 个石子，若剩下一个石子与窗口中与之最近的石子之间的空位数为 1，
        # 则只需要一次操作即可使 n 个石子连续，否则我们需要进行两步操作。比如有石子位置序列 1,2,3,
        # 4,6，则此时 1,2,3,4 连续，6 与其最近的 4 中间空位数为 1，我们只需要将位置为 1 的石子移
        # 动到位置为 5 的位置即可。否则若石子位置序列为 1,2,3,4,x，其中 x>6，则我们可以可以将位置
        # 为 1 的石子移动到位置为 6 的位置，然后将位置 x 的石子移动到 5 即可。其中剩下的一个石子在
        # 连续序列的左边时同理可以分析得到相同结论。
        # 否则我们选择包含石子最多的窗口即可，不妨设有 k 个石子，则此时需要 n−k 次操作将窗口中的空
        # 位填满。证明如下: 我们不妨设此时窗口的左端点已有石子（若没有，则可以将窗口不断右移直至窗口
        # 左端点存在石子，因为右移的过程中窗口中的石子个数只增不少，不会改变窗口石子最多的性质），若
        # 此时窗口右端点有石子，则剩下的 n−k 个石子可以依次移动到窗口中的空位中，否则此时窗口中石子
        # 个数少于 n−1，因为若石子个数等于 n−1 且窗口右端点无石子，此时为情况 1。那么外面至少有两个
        # 石子，若窗口右边存在两个及以上石子则一定可以将最右端的石子移动到窗口右端，否则若窗口右边存
        # 在一个石子，此时窗口左边必定至少有一个石子，可以将最做左边的石子移动到窗口右端，此时对于剩
        # 下的 n−k−1 个石子可以依次移动到窗口中剩下的空位中。此时总的移动数仍为 n−k。若窗口右边没有
        # 石子，则我们将窗口不断左移使得窗口右端存在石子，此时同上述的分析过程可以得到需要的总移动次
        # 数为 n−k。
        if stones[n-1]-stones[0]+1-n == 0: # 已经连续
            return [0, 0]
            # 求max
        max_ans = max(stones[n-1]-stones[1]+1-n, stones[n-2]-stones[0]+1-n)+1

        # 求min
        if stones[n-2]-stones[0]+1 == n-1:
            if stones[n-1] == stones[n-2]+2:
                min_ans = 1
            else:
                min_ans = 2
        elif stones[n-1]-stones[1]+1 == n-1:
            if stones[0] == stones[1]-2:
                min_ans = 1
            else:
                min_ans = 2
        else:
            max_cnt = 0
            cnt = 0
            idx1, idx2 = 0, 0
            while idx2 < n:
                while idx2 < n and stones[idx2]-stones[idx1]+1 <= n:
                    cnt += 1
                    idx2 += 1
                max_cnt = max(max_cnt, cnt)
                idx1 += 1
                cnt -= 1
            min_ans = n-max_cnt

        return [min_ans, max_ans]