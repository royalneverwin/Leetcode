class Solution {
public:
#define MOD (1000000000+7)
    /*
    我们用 f[i]表示以 s[i]为最后一个字符的子序列的数目。如果子序列中只有 s[i] 这一个字符，那么有一种方案；
    如果子序列中至少有两个字符，那么我们可以枚举倒数第二个字符来进行状态转移。容易想到的是：倒数第二个字符可以选择s[0],s[1],⋯,s[i−1] 中的某一个，这样就可以得到如下的状态转移方程：f[i]=f[0]+f[1]+⋯f[i−1]
    然而这样做会产生重复计数。如果 s[j_0] 和 s[j_1]这两个字符不相同，那么 f[j_0]和 f[j_1]对应的子序列是两个不相交的集合；但如果 s[j_0]和 s[j_1]这两个字符相同，那么 f[j_0]和 f[j_1]对应的子序列会包含重复的项。最简单的一个重复项就是只含有一个字符的子序列 s[j_0] 或者 s[j_1] 本身。
    那么我们该如何防止重复计数呢？可以发现，如果 j_0<j_1 那么 f[j_0] 一定是 f[j_1] 的一个真子集。这是因为：每一个以 s[j_0] 为最后一个字符的子序列，都可以把这个字符改成完全相同的 s[j_1]，计入到 f[j_1] 中。
    因此，对于每一种字符，我们只需要找到其最后一次出现的位置（并且在位置 i 之前），并将对应的 f 值累加进 f[i] 即可。
    由于本题中字符串只包含小写字母，我们可以用 last[k] 记录第 k (0≤k<26) 个小写字母最后一次出现的位置。如果它还没有出现过，那么 last[k]=−1。
    */
    int distinctSubseqII(string s) {
        int l = s.length();
        vector<int> dp(l, 0); // dp[i]表示的含义如上f[i]
        vector<int> last(26, -1);
        long long res;
        for(int i = 0; i < l; i++) {
            res = 1;
            for(int j = 0; j < 26; j++) {
                if (last[j] != -1) {
                    res += (long long)dp[last[j]];
                }
            }
            dp[i] = res % MOD;
            last[s[i]-'a'] = i;
        }
        res = 0;
        for(int j = 0; j < 26; j++) {
            if (last[j] != -1) {
                res += (long long)dp[last[j]];
            }
        }
        return res % MOD;
    }
};